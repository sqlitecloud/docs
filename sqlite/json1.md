---
title: JSON Functions And Operators
description: By default, SQLite supports twenty-nine functions and two operators for dealing with JSON values.
statement: SELECT json_object('id' , ArtistId, 'name', name) FROM Artist;
customClass: sqlite-doc
---

## 1. Overview

By default, SQLite supports twenty-nine functions and two operators for
dealing with JSON values. There are also two [table-valued
functions](https://sqlite.org/vtab.html#tabfunc2) that can be used to
decompose a JSON string.

There are 25 scalar functions and operators:

1.  [json](#jmini)(*json*)
2.  [jsonb](#jminib)(*json*)
3.  [json_array](#jarray)(*value1*,*value2*,...)
4.  [jsonb_array](#jarrayb)(*value1*,*value2*,...)
5.  [json_array_length](#jarraylen)(*json*)  
    [json_array_length](#jarraylen)(*json*,*path*)
6.  [json_error_position](#jerr)(*json*)
7.  [json_extract](#jex)(*json*,*path*,...)
8.  [jsonb_extract](#jexb)(*json*,*path*,...)
9.  *json* [-\>](#jptr) *path*
10. *json* [-\>\>](#jptr) *path*
11. [json_insert](#jins)(*json*,*path*,*value*,...)
12. [jsonb_insert](#jinsb)(*json*,*path*,*value*,...)
13. [json_object](#jobj)(*label1*,*value1*,...)
14. [jsonb_object](#jobjb)(*label1*,*value1*,...)
15. [json_patch](#jpatch)(*json*1,json2)
16. [jsonb_patch](#jpatchb)(*json*1,json2)
17. [json_remove](#jrm)(*json*,*path*,...)
18. [jsonb_remove](#jrmb)(*json*,*path*,...)
19. [json_replace](#jrepl)(*json*,*path*,*value*,...)
20. [jsonb_replace](#jreplb)(*json*,*path*,*value*,...)
21. [json_set](#jset)(*json*,*path*,*value*,...)
22. [jsonb_set](#jsetb)(*json*,*path*,*value*,...)
23. [json_type](#jtype)(*json*)  
    [json_type](#jtype)(*json*,*path*)
24. [json_valid](#jvalid)(*json*)  
    [json_valid](#jvalid)(*json*,flags)
25. [json_quote](#jquote)(*value*)

There are four [aggregate SQL functions](lang_aggfunc.html):

1.  [json_group_array](#jgrouparray)(*value*)
2.  [jsonb_group_array](#jgrouparrayb)(*value*)
3.  [json_group_object](#jgroupobject)(*label*,*value*)
4.  [jsonb_group_object](#jgroupobjectb)(name,*value*)

The two [table-valued functions](https://sqlite.org/vtab.html#tabfunc2)
are:

1.  [json_each](#jeach)(*json*)  
    [json_each](#jeach)(*json*,*path*)
2.  [json_tree](#jtree)(*json*)  
    [json_tree](#jtree)(*json*,*path*)

<span id="howtocompile"></span>

## 2. Compiling in JSON Support

The JSON functions and operators are built into SQLite by default, as of
SQLite version 3.38.0 (2022-02-22). They can be omitted by adding the
-DSQLITE_OMIT_JSON compile-time option. Prior to version 3.38.0, the
JSON functions were an extension that would only be included in builds
if the -DSQLITE_ENABLE_JSON1 compile-time option was included. In other
words, the JSON functions went from being opt-in with SQLite version
3.37.2 and earlier to opt-out with SQLite version 3.38.0 and later.

## 3. Interface Overview

SQLite stores JSON as ordinary text. Backwards compatibility constraints
mean that SQLite is only able to store values that are NULL, integers,
floating-point numbers, text, and BLOBs. It is not possible to add a new
"JSON" type.

## 3.1. JSON arguments

For functions that accept JSON as their first argument, that argument
can be a JSON object, array, number, string, or null. SQLite numeric
values and NULL values are interpreted as JSON numbers and nulls,
respectively. SQLite text values can be understood as JSON objects,
arrays, or strings. If an SQLite text value that is not a well-formed
JSON object, array, or string is passed into JSON function, that
function will usually throw an error. (Exceptions to this rule are
[json_valid()](json1#jvalid), [json_quote()](json1#jquote), and
[json_error_position()](json1#jerr).)

These routines understand all [rfc-8259 JSON
syntax](https://www.rfc-editor.org/rfc/rfc8259.txt) and also [JSON5
extensions](https://spec.json5.org/). JSON text generated by these
routines always strictly conforms to the [canonical JSON
definition](https://json.org) and does not contain any JSON5 or other
extensions. The ability to read and understand JSON5 was added in
version 3.42.0 (2023-05-16). Prior versions of SQLite would only read
canonical JSON. <span id="jsonbx"></span>

## 3.2. JSONB

Beginning with version 3.45.0 (2024-01-15), SQLite allows its internal
"parse tree" representation of JSON to be stored on disk, as a BLOB, in
a format that we call "JSONB". By storing SQLite's internal binary
representation of JSON directly in the database, applications can bypass
the overhead of parsing and rendering JSON when reading and updating
JSON values. The internal JSONB format is also uses slightly less disk
space then text JSON.

Any SQL function parameter that accepts text JSON as an input will also
accept a BLOB in the JSONB format. The function will operate the same in
either case, except that it will run faster when the input is JSONB,
since it does not need to run the JSON parser.

Most SQL functions that return JSON text have a corresponding function
that returns the equivalent JSONB. The functions that return JSON in the
text format begin with "`json_`" and functions that return the binary
JSONB format begin with "`jsonb_`".

### 3.2.1. The JSONB format

JSONB is a binary representation of JSON used by SQLite and is intended
for internal use by SQLite only. Applications should not use JSONB
outside of SQLite nor try to reverse-engineer the JSONB format.

The "JSONB" name is inspired by [PostgreSQL](https://postgresql.org),
but the on-disk format for SQLite's JSONB is not the same as
PostgreSQL's. The two formats have the same name, but are not binary
compatible. The PostgreSQL JSONB format claims to offer O(1) lookup of
elements in objects and arrays. SQLite's JSONB format makes no such
claim. SQLite's JSONB has O(N) time complexity for most operations in
SQLite, just like text JSON. The advantage of JSONB in SQLite is that it
is smaller and faster than text JSON - potentially several times faster.
There is space in the on-disk JSONB format to add enhancements and
future versions of SQLite might include options to provide O(1) lookup
of elements in JSONB, but no such capability is currently available.

### 3.2.2. Handling of malformed JSONB

The JSONB that is generated by SQLite will always be well-formed. If you
follow recommended practice and treat JSONB as an opaque BLOB, then you
will not have any problems. But JSONB is just a BLOB, so a mischievous
programmer could devise BLOBs that are similar to JSONB but that are
technically malformed. When misformatted JSONB is feed into JSON
functions, any of the following might happen:

- The SQL statement might abort with a "malformed JSON" error.

- The correct answer might be returned, if the malformed parts of the
  JSONB blob do not impact the answer.

- A goofy or nonsensical answer might be returned.

The way in which SQLite handles invalid JSONB might change from one
version of SQLite to the next. The system follows the
garbage-in/garbage-out rule: If you feed the JSON functions invalid
JSONB, you get back an invalid answer. If you are in doubt about the
validity of our JSONB, use the [json_valid()](json1#jvalid) function to
verify it.

We do make this one promise: Malformed JSONB will never cause a memory
error or similar problem that might lead to a vulnerability. Invalid
JSONB might lead to crazy answers, or it might cause queries to abort,
but it won't cause a crash. <span id="jsonpath"></span>

## 3.3. PATH arguments

For functions that accept PATH arguments, that PATH must be well-formed
or else the function will throw an error. A well-formed PATH is a text
value that begins with exactly one '\$' character followed by zero or
more instances of ".*objectlabel*" or "\[*arrayindex*\]".

The *arrayindex* is usually a non-negative integer *N*. In that case,
the array element selected is the *N*-th element of the array, starting
with zero on the left. The *arrayindex* can also be of the form
"**\#-**_N_" in which case the element selected is the *N*-th from the
right. The last element of the array is "**\#-1**". Think of the "#"
characters as the "number of elements in the array". Then the expression
"#-1" evaluates to the integer that corresponds to the last entry in the
array. It is sometimes useful for the array index to be just the **\#**
character, for example when appending a value to an existing JSON array:

- <span class="jex">json_set('\[0,1,2\]','\$\[#\]','new')</span>
  <span class="jans">→ '\[0,1,2,"new"\]'</span>

<span id="varg"></span>

## 3.4. VALUE arguments

For functions that accept "*value*" arguments (also shown as "*value1*"
and "*value2*"), those arguments are usually understood to be literal
strings that are quoted and become JSON string values in the result.
Even if the input *value* strings look like well-formed JSON, they are
still interpreted as literal strings in the result.

However, if a *value* argument comes directly from the result of another
JSON function or from [the -\> operator](json1#jptr) (but not [the -\>\>
operator](json1#jptr)), then the argument is understood to be actual
JSON and the complete JSON is inserted rather than a quoted string.

For example, in the following call to json_object(), the *value*
argument looks like a well-formed JSON array. However, because it is
just ordinary SQL text, it is interpreted as a literal string and added
to the result as a quoted string:

- <span class="jex">json_object('ex','\[52,3.14159\]')</span>
  <span class="jans">→ '{"ex":"\[52,3.14159\]"}'</span>
- <span class="jex">json_object('ex',('\[52,3.14159\]'-\>\>'\$'))</span>
  <span class="jans">→ '{"ex":"\[52,3.14159\]"}'</span>

But if the *value* argument in the outer json_object() call is the
result of another JSON function like [json()](json1#jmini) or
[json_array()](json1#jarray), then the value is understood to be actual
JSON and is inserted as such:

- <span class="jex">json_object('ex',json('\[52,3.14159\]'))</span>
  <span class="jans">→ '{"ex":\[52,3.14159\]}'</span>
- <span class="jex">json_object('ex',json_array(52,3.14159))</span>
  <span class="jans">→ '{"ex":\[52,3.14159\]}'</span>
- <span class="jex">json_object('ex','\[52,3.14159\]'-\>'\$')</span>
  <span class="jans">→ '{"ex":\[52,3.14159\]}'</span>

To be clear: "*json*" arguments are always interpreted as JSON
regardless of where the value for that argument comes from. But
"*value*" arguments are only interpreted as JSON if those arguments come
directly from another JSON function or [the -\> operator](json1#jptr).

Within JSON value arguments interpreted as JSON strings, Unicode escape
sequences are not treated as equivalent to the characters or escaped
control characters represented by the expressed Unicode code point. Such
escape sequences are not translated or specially treated; they are
treated as plain text by SQLite's JSON functions.

## 3.5. Compatibility

The current implementation of this JSON library uses a recursive descent
parser. In order to avoid using excess stack space, any JSON input that
has more than 1000 levels of nesting is considered invalid. Limits on
nesting depth are allowed for compatible implementations of JSON by
[RFC-8259 section 9](https://tools.ietf.org/html/rfc8259#section-9).
<span id="json5"></span>

## 3.6. JSON5 Extensions

Beginning in version 3.42.0 (2023-05-16), these routines will read and
interpret input JSON text that includes [JSON5](https://spec.json5.org/)
extensions. However, JSON text generated by these routines will always
be strictly conforming to the [canonical definition of
JSON](https://json.org).

Here is a synopsis of JSON5 extensions (adapted from the [JSON5
specification](https://spec.json5.org/#introduction)):

- Object keys may be unquoted identifiers.
- Objects may have a single trailing comma.
- Arrays may have a single trailing comma.
- Strings may be single quoted.
- Strings may span multiple lines by escaping new line characters.
- Strings may include new character escapes.
- Numbers may be hexadecimal.
- Numbers may have a leading or trailing decimal point.
- Numbers may be "Infinity", "-Infinity", and "NaN".
- Numbers may begin with an explicit plus sign.
- Single (//...) and multi-line (/\*...\*/) comments are allowed.
- Additional white space characters are allowed.

To convert string X from JSON5 into canonical JSON, invoke
"[json(X)](json1#jmini)". The output of the "[json()](json1#jmini)"
function will be canonical JSON regardless of any JSON5 extensions that
are present in the input. For backwards compatibility, the
[json_valid(X)](json1#jvalid) function without a "flags" argument
continues to report false for inputs that are not canonical JSON, even
if the input is JSON5 that the function is able to understand. To
determine whether or not an input string is valid JSON5, include the
0x02 bit in the "flags" argument to json_valid: "`json_valid(X,2)`".

These routines understand all of JSON5, plus a little more. SQLite
extends the JSON5 syntax in these two ways:

1.  Strict JSON5 requires that unquoted object keys must be ECMAScript
    5.1 IdentifierNames. But large unicode tables and lots of code is
    required in order to determine whether or not a key is an ECMAScript
    5.1 IdentifierName. For this reason, SQLite allows object keys to
    include any unicode characters greater than U+007f that are not
    whitespace characters. This relaxed definition of "identifier"
    greatly simplifies the implementation and allows the JSON parser to
    be smaller and run faster.

2.  JSON5 allows floating-point infinities to be expressed as
    "`Infinity`", "`-Infinity`", or "`+Infinity`" in exactly that case -
    the initial "I" is capitalized and all other characters are lower
    case. SQLite also allows the abbreviation "`Inf`" to be used in
    place of "`Infinity`" and it allows both keywords to appear in any
    combination of upper and lower case letters. Similarly, JSON5 allows
    "NaN" for not-a-number. SQLite extends this to also allow "QNaN" and
    "SNaN" in any combination of upper and lower case letters. Note that
    SQLite interprets NaN, QNaN, and SNaN as just an alternative
    spellings for "null". This extension has been added because (we are
    told) there exists a lot of JSON in the wild that includes these
    non-standard representations for infinity and not-a-number.

## 3.7. Performance Considerations

Most JSON functions do their internal processing using JSONB. So if the
input is text, they first most translate the input text into JSONB. If
the input is already in the JSONB format, no translation is needed, that
step can be skipped, and performance is faster.

For that reason, when an argument to one JSON function is supplied by
another JSON function, it is usually more efficient to use the
"`jsonb_`" variant for the function used as the argument.

- `... json_insert(A,'$.b',json(C)) ...`   ← Less efficient.
- `... json_insert(A,'$.b',jsonb(C)) ...`   ← More efficient.

The [aggregate JSON SQL functions](json1#jgroupobjectb) are an exception
to this rule. Those functions all do their processing using text instead
of JSONB. So for the aggregate JSON SQL functions, it is more efficient
for the arguments to be supplied using "`json_`" functions than
"`jsonb_`" functions.

- `... json_group_array(json(A))) ...`   ← More efficient.
- `... json_group_array(jsonb(A))) ...`   ← Less efficient.

## 4. Function Details

The following sections provide additional detail on the operation of the
various JSON functions and operators: <span id="jmini"></span>

## 4.1. The json() function

The json(X) function verifies that its argument X is a valid JSON string
or JSONB blob and returns a minified version of that JSON string with
all unnecessary whitespace removed. If X is not a well-formed JSON
string or JSONB blob, then this routine throws an error.

If the input is JSON5 text, then it is converted into canonical RFC-8259
text prior to being returned.

If the argument X to json(X) contains JSON objects with duplicate
labels, then it is undefined whether or not the duplicates are
preserved. The current implementation preserves duplicates. However,
future enhancements to this routine may choose to silently remove
duplicates.

Example:

- <span class="jex">json(' { "this" : "is", "a": \[ "test" \] }
  ')</span> <span class="jans">→ '{"this":"is","a":\["test"\]}'</span>

<span id="jminib"></span>

## 4.2. The jsonb() function

The jsonb(X) function returns the binary JSONB representation of the
JSON provided as argument X. An error is raised if X is TEXT that does
not have valid JSON syntax.

If X is a BLOB and appears to be JSONB, then this routine simply returns
a copy of X. Only the outer-most element of the JSONB input is examined,
however. The deep structure of the JSONB is not validated.
<span id="jarray"></span>

## 4.3. The json_array() function

The json_array() SQL function accepts zero or more arguments and returns
a well-formed JSON array that is composed from those arguments. If any
argument to json_array() is a BLOB then an error is thrown.

An argument with SQL type TEXT is normally converted into a quoted JSON
string. However, if the argument is the output from another json1
function, then it is stored as JSON. This allows calls to json_array()
and [json_object()](json1#jobj) to be nested. The [json()](json1#jmini)
function can also be used to force strings to be recognized as JSON.

Examples:

- <span class="jex">json_array(1,2,'3',4)</span> <span class="jans">→
  '\[1,2,"3",4\]'</span>
- <span class="jex">json_array('\[1,2\]')</span> <span class="jans">→
  '\["\[1,2\]"\]'</span>
- <span class="jex">json_array(json_array(1,2))</span>
  <span class="jans">→ '\[\[1,2\]\]'</span>
- <span class="jex">json_array(1,null,'3','\[4,5\]','{"six":7.7}')</span>
  <span class="jans">→ '\[1,null,"3","\[4,5\]","{\\six\\:7.7}"\]'</span>
- <span class="jex">json_array(1,null,'3',json('\[4,5\]'),json('{"six":7.7}'))</span>
  <span class="jans">→ '\[1,null,"3",\[4,5\],{"six":7.7}\]'</span>

<span id="jarrayb"></span>

## 4.4. The jsonb_array() function

The jsonb_array() SQL function works just like the
[json_array()](json1#jarray) function except that it returns the
constructed JSON array in the SQLite's private JSONB format rather than
in the standard RFC 8259 text format. <span id="jarraylen"></span>

## 4.5. The json_array_length() function

The json_array_length(X) function returns the number of elements in the
JSON array X, or 0 if X is some kind of JSON value other than an array.
The json_array_length(X,P) locates the array at path P within X and
returns the length of that array, or 0 if path P locates an element in X
that is not a JSON array, and NULL if path P does not locate any element
of X. Errors are thrown if either X is not well-formed JSON or if P is
not a well-formed path.

Examples:

- <span class="jex">json_array_length('\[1,2,3,4\]')</span>
  <span class="jans">→ 4</span>
- <span class="jex">json_array_length('\[1,2,3,4\]', '\$')</span>
  <span class="jans">→ 4</span>
- <span class="jex">json_array_length('\[1,2,3,4\]', '\$\[2\]')</span>
  <span class="jans">→ 0</span>
- <span class="jex">json_array_length('{"one":\[1,2,3\]}')</span>
  <span class="jans">→ 0</span>
- <span class="jex">json_array_length('{"one":\[1,2,3\]}',
  '\$.one')</span> <span class="jans">→ 3</span>
- <span class="jex">json_array_length('{"one":\[1,2,3\]}',
  '\$.two')</span> <span class="jans">→ NULL</span>

<span id="jerr"></span>

## 4.6. The json_error_position() function

The json_error_positionf(X) function returns 0 if the input X is a
well-formed JSON or JSON5 string. If the input X contains one or more
syntax errors, then this function returns the character position of the
first syntax error. The left-most character is position 1.

If the input X is a BLOB, then this routine returns 0 if X is a
well-formed JSONB blob. If the return value is positive, then it
represents the *approximate* 1-based position in the BLOB of the first
detected error.

The json_error_position() function was added with SQLite version 3.42.0
(2023-05-16). <span id="jex"></span>

## 4.7. The json_extract() function

The json_extract(X,P1,P2,...) extracts and returns one or more values
from the well-formed JSON at X. If only a single path P1 is provided,
then the SQL datatype of the result is NULL for a JSON null, INTEGER or
REAL for a JSON numeric value, an INTEGER zero for a JSON false value,
an INTEGER one for a JSON true value, the dequoted text for a JSON
string value, and a text representation for JSON object and array
values. If there are multiple path arguments (P1, P2, and so forth) then
this routine returns SQLite text which is a well-formed JSON array
holding the various values.

Examples:

- <span class="jex">json_extract('{"a":2,"c":\[4,5,{"f":7}\]}',
  '\$')</span> <span class="jans">→ '{"a":2,"c":\[4,5,{"f":7}\]}'</span>
- <span class="jex">json_extract('{"a":2,"c":\[4,5,{"f":7}\]}',
  '\$.c')</span> <span class="jans">→ '\[4,5,{"f":7}\]'</span>
- <span class="jex">json_extract('{"a":2,"c":\[4,5,{"f":7}\]}',
  '\$.c\[2\]')</span> <span class="jans">→ '{"f":7}'</span>
- <span class="jex">json_extract('{"a":2,"c":\[4,5,{"f":7}\]}',
  '\$.c\[2\].f')</span> <span class="jans">→ 7</span>
- <span class="jex">json_extract('{"a":2,"c":\[4,5\],"f":7}','\$.c','\$.a')</span>
  <span class="jans">→ '\[\[4,5\],2\]'</span>
- <span class="jex">json_extract('{"a":2,"c":\[4,5\],"f":7}','\$.c\[#-1\]')</span>
  <span class="jans">→ 5</span>
- <span class="jex">json_extract('{"a":2,"c":\[4,5,{"f":7}\]}',
  '\$.x')</span> <span class="jans">→ NULL</span>
- <span class="jex">json_extract('{"a":2,"c":\[4,5,{"f":7}\]}', '\$.x',
  '\$.a')</span> <span class="jans">→ '\[null,2\]'</span>
- <span class="jex">json_extract('{"a":"xyz"}', '\$.a')</span>
  <span class="jans">→ 'xyz'</span>
- <span class="jex">json_extract('{"a":null}', '\$.a')</span>
  <span class="jans">→ NULL</span>

There is a subtle incompatibility between the json_extract() function in
SQLite and the json_extract() function in MySQL. The MySQL version of
json_extract() always returns JSON. The SQLite version of json_extract()
only returns JSON if there are two or more PATH arguments (because the
result is then a JSON array) or if the single PATH argument references
an array or object. In SQLite, if json_extract() has only a single PATH
argument and that PATH references a JSON null or a string or a numeric
value, then json_extract() returns the corresponding SQL NULL, TEXT,
INTEGER, or REAL value.

The difference between MySQL json_extract() and SQLite json_extract()
really only stands out when accessing individual values within the JSON
that are strings or NULLs. The following table demonstrates the
difference:

| Operation                                   | SQLite Result | MySQL Result |
|---------------------------------------------|---------------|--------------|
| json_extract('{"a":null,"b":"xyz"}','\$.a') | NULL          | 'null'       |
| json_extract('{"a":null,"b":"xyz"}','\$.b') | 'xyz'         | '"xyz"'      |

<span id="jexb"></span>

## 4.8. The jsonb_extract() function

The jsonb_extract() function works the same as the
[json_extract()](json1#jex) function, except in cases where
json_extract() would normally return a text JSON array object, this
routine returns the array or object in the JSONB format. For the common
case where a text, numeric, null, or boolean JSON element is returned,
this routine works exactly the same as json_extract().
<span id="jptr"></span>

## 4.9. The -\> and -\>\> operators

Beginning with SQLite version 3.38.0 (2022-02-22), the -\> and -\>\>
operators are available for extracting subcomponents of JSON. The SQLite
implementation of -\> and -\>\> strives to be compatible with both MySQL
and PostgreSQL. The -\> and -\>\> operators take a JSON string or JSONB
blob as their left operand and a PATH expression or object field label
or array index as their right operand. The -\> operator returns a text
JSON representation of the selected subcomponent or NULL if that
subcomponent does not exist. The -\>\> operator returns an SQL TEXT,
INTEGER, REAL, or NULL value that represents the selected subcomponent,
or NULL if the subcomponent does not exist.

Both the -\> and -\>\> operators select the same subcomponent of the
JSON to their left. The difference is that -\> always returns a JSON
representation of that subcomponent and the -\>\> operator always
returns an SQL representation of that subcomponent. Thus, these
operators are subtly different from a two-argument
[json_extract()](json1#jex) function call. A call to json_extract() with
two arguments will return a JSON representation of the subcomponent if
and only if the subcomponent is a JSON array or object, and will return
an SQL representation of the subcomponent if the subcomponent is a JSON
null, string, or numeric value.

When the -\> operator returns JSON, it always returns the RFC 8565 text
representation of that JSON, not JSONB. Use the
[jsonb_extract()](json1#jexb) function if you need a subcomponent in the
JSONB format.

The right-hand operand to the -\> and -\>\> operators can be a
well-formed JSON path expression. This is the form used by MySQL. For
compatibility with PostgreSQL, the -\> and -\>\> operators also accept a
text object label or integer array index as their right-hand operand. If
the right operand is a text label X, then it is interpreted as the JSON
path '\$.X'. If the right operand is an integer value N, then it is
interpreted as the JSON path '\$\[N\]'.

Examples:

- <span class="jex">'{"a":2,"c":\[4,5,{"f":7}\]}' -\> '\$'</span>
  <span class="jans">→ '{"a":2,"c":\[4,5,{"f":7}\]}'</span>
- <span class="jex">'{"a":2,"c":\[4,5,{"f":7}\]}' -\> '\$.c'</span>
  <span class="jans">→ '\[4,5,{"f":7}\]'</span>
- <span class="jex">'{"a":2,"c":\[4,5,{"f":7}\]}' -\> 'c'</span>
  <span class="jans">→ '\[4,5,{"f":7}\]'</span>
- <span class="jex">'{"a":2,"c":\[4,5,{"f":7}\]}' -\> '\$.c\[2\]'</span>
  <span class="jans">→ '{"f":7}'</span>
- <span class="jex">'{"a":2,"c":\[4,5,{"f":7}\]}' -\>
  '\$.c\[2\].f'</span> <span class="jans">→ '7'</span>
- <span class="jex">'{"a":2,"c":\[4,5,{"f":7}\]}' -\>\>
  '\$.c\[2\].f'</span> <span class="jans">→ 7</span>
- <span class="jex">'{"a":2,"c":\[4,5,{"f":7}\]}' -\> 'c' -\> 2 -\>\>
  'f'</span> <span class="jans">→ 7</span>
- <span class="jex">'{"a":2,"c":\[4,5\],"f":7}' -\> '\$.c\[#-1\]'</span>
  <span class="jans">→ '5'</span>
- <span class="jex">'{"a":2,"c":\[4,5,{"f":7}\]}' -\> '\$.x'</span>
  <span class="jans">→ NULL</span>
- <span class="jex">'\[11,22,33,44\]' -\> 3</span> <span class="jans">→
  '44'</span>
- <span class="jex">'\[11,22,33,44\]' -\>\> 3</span>
  <span class="jans">→ 44</span>
- <span class="jex">'{"a":"xyz"}' -\> '\$.a'</span> <span class="jans">→
  '"xyz"'</span>
- <span class="jex">'{"a":"xyz"}' -\>\> '\$.a'</span>
  <span class="jans">→ 'xyz'</span>
- <span class="jex">'{"a":null}' -\> '\$.a'</span> <span class="jans">→
  'null'</span>
- <span class="jex">'{"a":null}' -\>\> '\$.a'</span>
  <span class="jans">→ NULL</span>

<span id="jins"></span> <span id="jrepl"></span> <span id="jset"></span>

## 4.10. The json_insert(), json_replace, and json_set() functions

The json_insert(), json_replace, and json_set() functions all take a
single JSON value as their first argument followed by zero or more pairs
of path and value arguments, and return a new JSON string formed by
updating the input JSON by the path/value pairs. The functions differ
only in how they deal with creating new values and overwriting
preexisting values.

| Function       | Overwrite if already exists? | Create if does not exist? |
|----------------|:----------------------------:|:-------------------------:|
| json_insert()  |              No              |            Yes            |
| json_replace() |             Yes              |            No             |
| json_set()     |             Yes              |            Yes            |

The json_insert(), json_replace(), and json_set() functions always take
an odd number of arguments. The first argument is always the original
JSON to be edited. Subsequent arguments occur in pairs with the first
element of each pair being a path and the second element being the value
to insert or replace or set on that path.

Edits occur sequentially from left to right. Changes caused by prior
edits can affect the path search for subsequent edits.

If the value of a path/value pair is an SQLite TEXT value, then it is
normally inserted as a quoted JSON string, even if the string looks like
valid JSON. However, if the value is the result of another json function
(such as [json()](json1#jmini) or [json_array()](json1#jarray) or
[json_object()](json1#jobj)) or if it is the result of [the -\>
operator](json1#jptr), then it is interpreted as JSON and is inserted as
JSON retaining all of its substructure. Values that are the result of
[the -\>\> operator](json1#jptr) are always interpreted as TEXT and are
inserted as a JSON string even if they look like valid JSON.

These routines throw an error if the first JSON argument is not
well-formed or if any PATH argument is not well-formed or if any
argument is a BLOB.

To append an element onto the end of an array, using json_insert() with
an array index of "#". Examples:

- <span class="jex">json_insert('\[1,2,3,4\]','\$\[#\]',99)</span>
  <span class="jans">→ '\[1,2,3,4,99\]'</span>
- <span class="jex">json_insert('\[1,\[2,3\],4\]','\$\[1\]\[#\]',99)</span>
  <span class="jans">→ '\[1,\[2,3,99\],4\]'</span>

Other examples:

- <span class="jex">json_insert('{"a":2,"c":4}', '\$.a', 99)</span>
  <span class="jans">→ '{"a":2,"c":4}'</span>
- <span class="jex">json_insert('{"a":2,"c":4}', '\$.e', 99)</span>
  <span class="jans">→ '{"a":2,"c":4,"e":99}'</span>
- <span class="jex">json_replace('{"a":2,"c":4}', '\$.a', 99)</span>
  <span class="jans">→ '{"a":99,"c":4}'</span>
- <span class="jex">json_replace('{"a":2,"c":4}', '\$.e', 99)</span>
  <span class="jans">→ '{"a":2,"c":4}'</span>
- <span class="jex">json_set('{"a":2,"c":4}', '\$.a', 99)</span>
  <span class="jans">→ '{"a":99,"c":4}'</span>
- <span class="jex">json_set('{"a":2,"c":4}', '\$.e', 99)</span>
  <span class="jans">→ '{"a":2,"c":4,"e":99}'</span>
- <span class="jex">json_set('{"a":2,"c":4}', '\$.c',
  '\[97,96\]')</span> <span class="jans">→
  '{"a":2,"c":"\[97,96\]"}'</span>
- <span class="jex">json_set('{"a":2,"c":4}', '\$.c',
  json('\[97,96\]'))</span> <span class="jans">→
  '{"a":2,"c":\[97,96\]}'</span>
- <span class="jex">json_set('{"a":2,"c":4}', '\$.c',
  json_array(97,96))</span> <span class="jans">→
  '{"a":2,"c":\[97,96\]}'</span>

<span id="jinsb"></span> <span id="jreplb"></span>
<span id="jsetb"></span>

## 4.11. The jsonb_insert(), jsonb_replace, and jsonb_set() functions

The jsonb_insert(), jsonb_replace(), and jsonb_set() functions work the
same as [json_insert()](json1#jins), [json_replace()](json1#jrepl), and
[json_set()](json1#jset), respectively, except that "`jsonb_`" versions
return their result in the binary JSONB format. <span id="jobj"></span>

## 4.12. The json_object() function

The json_object() SQL function accepts zero or more pairs of arguments
and returns a well-formed JSON object that is composed from those
arguments. The first argument of each pair is the label and the second
argument of each pair is the value. If any argument to json_object() is
a BLOB then an error is thrown.

The json_object() function currently allows duplicate labels without
complaint, though this might change in a future enhancement.

An argument with SQL type TEXT it is normally converted into a quoted
JSON string even if the input text is well-formed JSON. However, if the
argument is the direct result from another JSON function or [the -\>
operator](json1#jptr) (but not [the -\>\> operator](json1#jptr)), then
it is treated as JSON and all of its JSON type information and
substructure is preserved. This allows calls to json_object() and
[json_array()](json1#jarray) to be nested. The [json()](json1#jmini)
function can also be used to force strings to be recognized as JSON.

Examples:

- <span class="jex">json_object('a',2,'c',4)</span> <span class="jans">→
  '{"a":2,"c":4}'</span>
- <span class="jex">json_object('a',2,'c','{e:5}')</span>
  <span class="jans">→ '{"a":2,"c":"{e:5}"}'</span>
- <span class="jex">json_object('a',2,'c',json_object('e',5))</span>
  <span class="jans">→ '{"a":2,"c":{"e":5}}'</span>

<span id="jobjb"></span>

## 4.13. The jsonb_object() function

The jsonb_object() function works just like the
[json_object()](json1#jobjb) function except that the generated object
is returned in the binary JSONB format. <span id="jpatch"></span>

## 4.14. The json_patch() function

The json_patch(T,P) SQL function runs the
[RFC-7396](https://tools.ietf.org/html/rfc7396) MergePatch algorithm to
apply patch P against input T. The patched copy of T is returned.

MergePatch can add, modify, or delete elements of a JSON Object, and so
for JSON Objects, the json_patch() routine is a generalized replacement
for [json_set()](json1#jset) and [json_remove()](json1#jrm). However,
MergePatch treats JSON Array objects as atomic. MergePatch cannot append
to an Array nor modify individual elements of an Array. It can only
insert, replace, or delete the whole Array as a single unit. Hence,
json_patch() is not as useful when dealing with JSON that includes
Arrays, especially Arrays with lots of substructure.

Examples:

- <span class="jex">json_patch('{"a":1,"b":2}','{"c":3,"d":4}')</span>
  <span class="jans">→ '{"a":1,"b":2,"c":3,"d":4}'</span>
- <span class="jex">json_patch('{"a":\[1,2\],"b":2}','{"a":9}')</span>
  <span class="jans">→ '{"a":9,"b":2}'</span>
- <span class="jex">json_patch('{"a":\[1,2\],"b":2}','{"a":null}')</span>
  <span class="jans">→ '{"b":2}'</span>
- <span class="jex">json_patch('{"a":1,"b":2}','{"a":9,"b":null,"c":8}')</span>
  <span class="jans">→ '{"a":9,"c":8}'</span>
- <span class="jex">json_patch('{"a":{"x":1,"y":2},"b":3}','{"a":{"y":9},"c":8}')</span>
  <span class="jans">→ '{"a":{"x":1,"y":9},"b":3,"c":8}'</span>

<span id="jpatchb"></span>

## 4.15. The jsonb_patch() function

The jsonb_patch() function works just like the
[json_patch()](json1#jpatchb) function except that the patched JSON is
returned in the binary JSONB format. <span id="jrm"></span>

## 4.16. The json_remove() function

The json_remove(X,P,...) function takes a single JSON value as its first
argument followed by zero or more path arguments. The
json_remove(X,P,...) function returns a copy of the X parameter with all
the elements identified by path arguments removed. Paths that select
elements not found in X are silently ignored.

Removals occurs sequentially from left to right. Changes caused by prior
removals can affect the path search for subsequent arguments.

If the json_remove(X) function is called with no path arguments, then it
returns the input X reformatted, with excess whitespace removed.

The json_remove() function throws an error if the first argument is not
well-formed JSON or if any later argument is not a well-formed path.

Examples:

- <span class="jex">json_remove('\[0,1,2,3,4\]','\$\[2\]')</span>
  <span class="jans">→ '\[0,1,3,4\]'</span>
- <span class="jex">json_remove('\[0,1,2,3,4\]','\$\[2\]','\$\[0\]')</span>
  <span class="jans">→ '\[1,3,4\]'</span>
- <span class="jex">json_remove('\[0,1,2,3,4\]','\$\[0\]','\$\[2\]')</span>
  <span class="jans">→ '\[1,2,4\]'</span>
- <span class="jex">json_remove('\[0,1,2,3,4\]','\$\[#-1\]','\$\[0\]')</span>
  <span class="jans">→ '\[1,2,3\]'</span>
- <span class="jex">json_remove('{"x":25,"y":42}')</span>
  <span class="jans">→ '{"x":25,"y":42}'</span>
- <span class="jex">json_remove('{"x":25,"y":42}','\$.z')</span>
  <span class="jans">→ '{"x":25,"y":42}'</span>
- <span class="jex">json_remove('{"x":25,"y":42}','\$.y')</span>
  <span class="jans">→ '{"x":25}'</span>
- <span class="jex">json_remove('{"x":25,"y":42}','\$')</span>
  <span class="jans">→ NULL</span>

<span id="jrmb"></span>

## 4.17. The jsonb_remove() function

The jsonb_remove() function works just like the
[json_remove()](json1#jrmb) function except that the edited JSON result
is returned in the binary JSONB format. <span id="jtype"></span>

## 4.18. The json_type() function

The json_type(X) function returns the "type" of the outermost element of
X. The json_type(X,P) function returns the "type" of the element in X
that is selected by path P. The "type" returned by json_type() is one of
the following SQL text values: 'null', 'true', 'false', 'integer',
'real', 'text', 'array', or 'object'. If the path P in json_type(X,P)
selects an element that does not exist in X, then this function returns
NULL.

The json_type() function throws an error if its first argument is not
well-formed JSON or JSONB or if its second argument is not a well-formed
JSON path.

Examples:

- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}')</span>
  <span class="jans">→ 'object'</span>
- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}','\$')</span>
  <span class="jans">→ 'object'</span>
- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}','\$.a')</span>
  <span class="jans">→ 'array'</span>
- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}','\$.a\[0\]')</span>
  <span class="jans">→ 'integer'</span>
- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}','\$.a\[1\]')</span>
  <span class="jans">→ 'real'</span>
- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}','\$.a\[2\]')</span>
  <span class="jans">→ 'true'</span>
- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}','\$.a\[3\]')</span>
  <span class="jans">→ 'false'</span>
- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}','\$.a\[4\]')</span>
  <span class="jans">→ 'null'</span>
- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}','\$.a\[5\]')</span>
  <span class="jans">→ 'text'</span>
- <span class="jex">json_type('{"a":\[2,3.5,true,false,null,"x"\]}','\$.a\[6\]')</span>
  <span class="jans">→ NULL</span>

<span id="jvalid"></span>

## 4.19. The json_valid() function

The json_valid(X,Y) function return 1 if the argument X is well-formed
JSON, or returns 0 if X is not well-formed. The Y parameter is an
integer bitmask that defines what is meant by "well-formed". The
following bits of Y are currently defined:

- **0x01** → The input is text that strictly complies with canonical
  RFC-8259 JSON, without any extensions.
- **0x02** → The input is text that is JSON with [JSON5](json1#json5)
  extensions described above.
- **0x04** → The input is a BLOB that superficially appears to be
  [JSONB](json1#jsonbx).
- **0x08** → The input is a BLOB that strictly conforms to the internal
  [JSONB](json1#jsonbx) format.

By combining bits, the following useful values of Y can be derived:

- **1** → X is RFC-8259 JSON text
- **2** → X is [JSON5](json1#json5) text
- **4** → X is probably [JSONB](json1#jsonbx)
- **5** → X is RFC-8259 JSON text or [JSONB](json1#jsonbx)
- **6** → X is [JSON5](json1#json5) text or [JSONB](json1#jsonbx) ←
  *This is probably the value you want*
- **8** → X is strictly conforming [JSONB](json1#jsonbx)
- **9** → X is RFC-8259 or strictly conforming [JSONB](json1#jsonbx)
- **10** → X is JSON5 or strictly conforming [JSONB](json1#jsonbx)

The Y parameter is optional. If omitted, it defaults to 1, which means
that the default behavior is to return true only if the input X is
strictly conforming RFC-8259 JSON text without any extensions. This
makes the one-argument version of json_valid() compatible with older
versions of SQLite, prior to the addition of support for
[JSON5](json1#json5) and [JSONB](json1#jsonbx).

The difference between 0x04 and 0x08 bits in the Y parameter is that
0x04 only examines the outer wrapper of the BLOB to see if it
superficially looks like [JSONB](json1#jsonbx). This is sufficient for
must purposes and is very fast. The 0x08 bit does a thorough examination
of all internal details of the BLOB. The 0x08 bit takes time that is
linear in the size of the X input and is much slower. The 0x04 bit is
recommended for most purposes.

If you just want to know if a value is a plausible input to one of the
other JSON functions, a Y value of 6 is probably what you want to use.

Any Y value less than 1 or greater than 15 raises an error, for the
latest version of json_valid(). However, future versions of json_valid()
might be enhanced to accept flag values outside of this range, having
new meanings that we have not yet thought of.

If either X or Y inputs to json_valid() are NULL, then the function
returns NULL.

Examples:

- <span class="jex">json_valid('{"x":35}')</span> <span class="jans">→
  1</span>
- <span class="jex">json_valid('{x:35}')</span> <span class="jans">→
  0</span>
- <span class="jex">json_valid('{x:35}',6)</span> <span class="jans">→
  1</span>
- <span class="jex">json_valid('{"x":35')</span> <span class="jans">→
  0</span>
- <span class="jex">json_valid(NULL)</span> <span class="jans">→
  NULL</span>

<span id="jquote"></span>

## 4.20. The json_quote() function

The json_quote(X) function converts the SQL value X (a number or a
string) into its corresponding JSON representation. If X is a JSON value
returned by another JSON function, then this function is a no-op.

Examples:

- <span class="jex">json_quote(3.14159)</span> <span class="jans">→
  3.14159</span>
- <span class="jex">json_quote('verdant')</span> <span class="jans">→
  '"verdant"'</span>
- <span class="jex">json_quote('\[1\]')</span> <span class="jans">→
  '"\[1\]"'</span>
- <span class="jex">json_quote(json('\[1\]'))</span>
  <span class="jans">→ '\[1\]'</span>
- <span class="jex">json_quote('\[1,')</span> <span class="jans">→
  '"\[1,"'</span>

<span id="jgrouparray"></span> <span id="jgroupobject"></span>
<span id="jgrouparrayb"></span> <span id="jgroupobjectb"></span>

## 4.21. Array and object aggregate functions

The json_group_array(X) function is an [aggregate SQL
function](lang_aggfunc.html) that returns a JSON array comprised of all
X values in the aggregation. Similarly, the
json_group_object(NAME,VALUE) function returns a JSON object comprised
of all NAME/VALUE pairs in the aggregation. The "`jsonb_`" variants are
the same except that they return their result in the binary
[JSONB](json1#jsonbx) format. <span id="jeach"></span>
<span id="jtree"></span>

## 4.22. The json_each() and json_tree() table-valued functions

The json_each(X) and json_tree(X) [table-valued
functions](https://www.sqlite.org/vtab.html#tabfunc2) walk the JSON
value provided as their first argument and return one row for each
element. The json_each(X) function only walks the immediate children of
the top-level array or object, or just the top-level element itself if
the top-level element is a primitive value. The json_tree(X) function
recursively walks through the JSON substructure starting with the
top-level element.

The json_each(X,P) and json_tree(X,P) functions work just like their
one-argument counterparts except that they treat the element identified
by path P as the top-level element.

The schema for the table returned by json_each() and json_tree() is as
follows:

>     CREATE TABLE json_tree(
>         key ANY,             -- key for current element relative to its parent
>         value ANY,           -- value for the current element
>         type TEXT,           -- 'object','array','string','integer', etc.
>         atom ANY,            -- value for primitive types, null for array & object
>         id INTEGER,          -- integer ID for this element
>         parent INTEGER,      -- integer ID for the parent of this element
>         fullkey TEXT,        -- full path describing the current element
>         path TEXT,           -- path to the container of the current row
>         json JSON HIDDEN,    -- 1st input parameter: the raw JSON
>         root TEXT HIDDEN     -- 2nd input parameter: the PATH at which to start
>     );

The "key" column is the integer array index for elements of a JSON array
and the text label for elements of a JSON object. The key column is NULL
in all other cases.

The "atom" column is the SQL value corresponding to primitive elements -
elements other than JSON arrays and objects. The "atom" column is NULL
for a JSON array or object. The "value" column is the same as the "atom"
column for primitive JSON elements but takes on the text JSON value for
arrays and objects.

The "type" column is an SQL text value taken from ('null', 'true',
'false', 'integer', 'real', 'text', 'array', 'object') according to the
type of the current JSON element.

The "id" column is an integer that identifies a specific JSON element
within the complete JSON string. The "id" integer is an internal
housekeeping number, the computation of which might change in future
releases. The only guarantee is that the "id" column will be different
for every row.

The "parent" column is always NULL for json_each(). For json_tree(), the
"parent" column is the "id" integer for the parent of the current
element, or NULL for the top-level JSON element or the element
identified by the root path in the second argument.

The "fullkey" column is a text path that uniquely identifies the current
row element within the original JSON string. The complete key to the
true top-level element is returned even if an alternative starting point
is provided by the "root" argument.

The "path" column is the path to the array or object container that
holds the current row, or the path to the current row in the case where
the iteration starts on a primitive type and thus only provides a single
row of output.

### 4.22.1. Examples using json_each() and json_tree()

Suppose the table "CREATE TABLE user(name,phone)" stores zero or more
phone numbers as a JSON array object in the user.phone field. To find
all users who have any phone number with a 704 area code:

>     SELECT DISTINCT user.name
>       FROM user, json_each(user.phone)
>      WHERE json_each.value LIKE '704-%';

Now suppose the user.phone field contains plain text if the user has
only a single phone number and a JSON array if the user has multiple
phone numbers. The same question is posed: "Which users have a phone
number in the 704 area code?" But now the json_each() function can only
be called for those users that have two or more phone numbers since
json_each() requires well-formed JSON as its first argument:

>     SELECT name FROM user WHERE phone LIKE '704-%'
>     UNION
>     SELECT user.name
>       FROM user, json_each(user.phone)
>      WHERE json_valid(user.phone)
>        AND json_each.value LIKE '704-%';

Consider a different database with "CREATE TABLE big(json JSON)". To see
a complete line-by-line decomposition of the data:

>     SELECT big.rowid, fullkey, value
>       FROM big, json_tree(big.json)
>      WHERE json_tree.type NOT IN ('object','array');

In the previous, the "type NOT IN ('object','array')" term of the WHERE
clause suppresses containers and only lets through leaf elements. The
same effect could be achieved this way:

>     SELECT big.rowid, fullkey, atom
>       FROM big, json_tree(big.json)
>      WHERE atom IS NOT NULL;

Suppose each entry in the BIG table is a JSON object with a '\$.id'
field that is a unique identifier and a '\$.partlist' field that can be
a deeply nested object. You want to find the id of every entry that
contains one or more references to uuid
'6fa5181e-5721-11e5-a04e-57f3d7b32808' anywhere in its '\$.partlist'.

>     SELECT DISTINCT json_extract(big.json,'$.id')
>       FROM big, json_tree(big.json, '$.partlist')
>      WHERE json_tree.key='uuid'
>        AND json_tree.value='6fa5181e-5721-11e5-a04e-57f3d7b32808';
