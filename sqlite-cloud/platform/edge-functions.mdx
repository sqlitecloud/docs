---
title: Edge Functions
description: SQLite Cloud offers powerful edge functions for performant data processing and third-party integrations.
category: platform
status: publish
slug: edge-functions
---
import VideoPlayer from '@commons-components/Video/VideoPlayer.astro';
import edgeFunctions from '@docs-website-assets/introduction/video/dashboard_edge_functions.mp4';

Edge functions let you define custom logic to run on the same nodes as your database files for ultra-fast performance.

You can write edge functions directly in the SQLite Cloud dashboard using JavaScript, TypeScript, or SQL. Importing modules is not currently supported.

Edge functions can be called remotely over HTTP or Websockets via API, or triggered by database events via SQLite Cloud [Webhooks](https://docs.sqlitecloud.io/docs/webhooks). Each function runs in an isolated environment using the Bun runtime. 

Turning on linearizable reads ensures strong consistency, but may introduce some latency. When eventual consistency is sufficient, we recommend leaving linearizable reads off.

## Getting Started

This guide explains how to create, deploy, and test Edge Functions in the SQLite Cloud UI.

<VideoPlayer src={edgeFunctions} />



1. Open the Edge Functions Section
    - From the left-hand sidebar, click the **Edge Functions** icon.  
    - You will see the list of your functions on the left and the code editor on the right.

2. Create a New Function
    - Click the **+** button next to *Filter functions...*.  
    - Choose the function type: **SQL**, **JavaScript**, or **TypeScript**.  
    - A new function (e.g., `function-1`) will appear in the list.

3. Write Your Function Code
    - Use the editor to implement your logic.  
    - You can include request parameters, execute SQL queries, and return custom objects.  

4. Select the Target Database
    - At the bottom of the editor, choose the database (e.g., `chinook.sqlite`).  
    - You can search and switch databases if needed.  

5. Deploy the Function
    - Before testing, you must **Deploy** the function.  
    - Click the **Deploy** button in the bottom-right corner.  
    - The function is now active and ready to be tested.  

6. Test the Function
    - After deployment, click **Test**.  
    - A panel will open on the right where you can configure:
      - **User** → choose a user with access to the selected database.  
      - **API Key** → select the appropriate key.  
      - **Request Body** → provide JSON input (e.g., `{ "filter": "a" }`).  
      - **Query Parameters** → add parameters (e.g., `limit = 10`).  
      - Click **Send Request** to execute the test.

7. Review the Response
    - The response will be shown at the bottom of the test panel.  
    - It includes your custom message, the SQL results, and the request object.

8. Enable Linearizable Reads (Optional)
    - If your database is frequently modified and you want strong consistency,  
      toggle **Linearizable** at the bottom before testing or deploying.

9. View the Function Details
    - Switch to the **Details** tab to check deployment information.  
    - You can see:
      - The **last deployed date and time**.  
      - The **Function URL**, which you can copy and use to call the function from external applications



#### Note:
Functions should return a JSON-serializable object with a data field:
```js
return {
  data: {
    // your return object
  }
}
```

### Authorization
Edge functions that access your SQLite databases must be authorized via API key. 

An API key must be sent in the request url as a query parameter (`?apikey=YOUR_API_KEY`) or as an attribute in the request body (`{ apikey: YOUR_API_KEY }`).

### Execution

Edge functions can be called via HTTP GET and POST methods. You can pass additional values to your edge function in two ways:
- Query parameters: Accessible via `request.params`
- Request body: Accessible via `request.data`


## Guides
### Interacting with your Database
Use the global `connection` object to access and manipulate your database.
```js
const customers = await connection.sql`SELECT * FROM customers;`
return {
  data: customers
}
```

Select the database you would like to access from the "Database" dropdown, or select the database you want to use in your SQL query with the [USE command](https://docs.sqlitecloud.io/docs/database-commands).

```js
const customers = await connection.sql`USE DATABASE chinook.sqlite; SELECT * FROM customers;`;
return {
  data: customers
}
```

### Storing and Accessing Environment Variables
Environment variables can be accessed and stored with the ENV command. ENV variables are stored in the server settings file and are project-specific.
Use the following commands to set and read values in your server settings file:

* [LIST ENV](https://docs.sqlitecloud.io/docs/settings-commands#list-env)
* [SET ENV](https://docs.sqlitecloud.io/docs/settings-commands#set-env) key VALUE value
* [GET ENV](https://docs.sqlitecloud.io/docs/settings-commands#get-env) key
* [REMOVE ENV](https://docs.sqlitecloud.io/docs/settings-commands#remove-env) key

You can also add environment variables in the UI by navigating to the "Environment Variables" section and clicking the "Create" button.


### Handling Errors
In case of error we return an HTTP error code and a JSON with the error message. Manually throwing an error in your code results in a 500 response. You may also return an error. 

## Examples

### Assigning and Notifying a Support Rep on User Sign up

```js
// Get secret from database
const slackWebhookEndpoint = await connection.sql`GET ENV slack_webhook_endpoint`;

// Get record sent in body via webhook
const content = request.data;
const database = content.database;
const primaryKey = content.data[0];
const newCustomer = await connection.sql`USE DATABASE ${database}; SELECT * FROM customers WHERE CustomerId = ${primaryKey};`;

// Sample business logic - assign and notify support rep
// Get reps from database
const reps = await connection.sql`SELECT id, name, country FROM reps`;
const rep = reps.find(({ country }) => country === newCustomer.country.toLowerCase());

// Define helpers to assign and notify
const assignRep = async (repId, customerId) => await connection.sql`UPDATE customers SET SupportRepId = ${repId} WHERE CustomerId = ${customerId}`;
const notifyRep = async (repName, customer) => {
    const message = `@${repName}: New User Sign Up - ${JSON.stringify(customer)}`
    try {
        await fetch(slackWebhookEndpoint, { body: JSON.stringify({ text: message }), method: 'POST', 'Content-type': 'application/json'  });
    } catch (err) {
        await fetch(slackWebhookEndpoint, { body: JSON.stringify({ text: err }), method: 'POST', 'Content-type': 'application/json'  });
    }
} 

// Call async functions
await assignRep(rep.id, newCustomer.id);
await notifyRep(rep.name, newCustomer);

return {
    data: 'OK'
}
```